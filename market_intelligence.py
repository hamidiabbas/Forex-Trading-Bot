"""
/******************************************************************************
 *
 * PROJECT NAME:        Algorithmic Forex Trading Bot
 *
 * FILE NAME:           market_intelligence.py
 *
 * PURPOSE:
 *
 * This module serves as the analytical engine of the trading bot. It is
 * responsible for transforming raw price data into actionable market
 * intelligence. This includes performing multi-timeframe analysis,
 * algorithmically identifying key market structures like support and
 * resistance, determining the current market regime (e.g., trending,
 * ranging), and calculating the relative strength of currencies. The
 * insights generated by this module form the foundation upon which the
 * Strategy Manager makes its trading decisions.
 *
 * AUTHOR:              Gemini Al
 *
 * DATE:                July 20, 2025
 *
 * VERSION:             4.0
 *
 ******************************************************************************/
"""
import pandas as pd
import pandas_ta as ta
import numpy as np
from scipy.signal import find_peaks

class MarketIntelligence:
    def __init__(self, data_handler, config):
        self.data_handler = data_handler
        self.config = config

    def analyze_all_timeframes(self, symbol):
        analyzed_data = {}
        for tf_name, tf_value in self.config.TIMEFRAMES.items():
            df = self.data_handler.get_price_data(symbol, tf_value, 500)
            if df is not None:
                analyzed_data[tf_value] = self._analyze_data(df)
        return analyzed_data

    def _analyze_data(self, df):
        # Use a try-except block to handle potential errors during indicator calculation
        try:
            df.ta.adx(length=14, append=True)
            df.ta.bbands(length=20, std=2, append=True)
            df.ta.atr(length=14, append=True)
            df.ta.sma(length=self.config.TREND_STRATEGY_MA_PERIOD, append=True)
            # Add RSI calculation needed for range strategy
            df.ta.rsi(length=14, append=True)
            return df.dropna()
        except Exception as e:
            print(f"Error calculating indicators: {e}")
            return pd.DataFrame() # Return empty dataframe on error


    def identify_support_resistance(self, df, lookback=60, tolerance=0.01):
        if df.empty or len(df) < lookback:
            return {'support': [], 'resistance': []}
        highs = df['High'][-lookback:]
        lows = df['Low'][-lookback:]
        resistance_peaks, _ = find_peaks(highs, distance=5, prominence=0.001)
        support_troughs, _ = find_peaks(-lows, distance=5, prominence=0.001)
        resistance_levels = highs.iloc[resistance_peaks].tolist()
        support_levels = lows.iloc[support_troughs].tolist()
        resistance_levels = self._cluster_levels(resistance_levels, tolerance)
        support_levels = self._cluster_levels(support_levels, tolerance)
        return {'support': support_levels, 'resistance': resistance_levels}

    def _cluster_levels(self, levels, tolerance):
        if not levels: return []
        levels.sort()
        clustered_levels = []
        current_cluster = [levels[0]]

        for level in levels[1:]:
            if (level - current_cluster[-1]) / current_cluster[-1] < tolerance:
                current_cluster.append(level)
            else:
                clustered_levels.append(np.mean(current_cluster))
                current_cluster = [level]
        clustered_levels.append(np.mean(current_cluster))
        return clustered_levels

    def determine_market_regime(self, df):
        if df.empty or len(df) < 100: # Ensure enough data for rolling window
            return "Unknown"
        
        adx = df['ADX_14'].iloc[-1]
        bb_upper = df['BBU_20_2.0'].iloc[-1]
        bb_lower = df['BBL_20_2.0'].iloc[-1]
        bb_middle = df['BBM_20_2.0'].iloc[-1]
        
        bb_width = (bb_upper - bb_lower) / bb_middle
        bb_width_history = (df['BBU_20_2.0'] - df['BBL_20_2.0']) / df['BBM_20_2.0']

        # --- THIS IS THE CORRECTED LINE ---
        # We compare the current width to the most recent value of the rolling minimum
        if adx > 25: # Loosened the trend threshold slightly
            return "Trend"
        elif bb_width < bb_width_history.rolling(100).min().iloc[-1] * 1.2: # Loosened squeeze factor
            return "Breakout-Pending"
        else:
            return "Ranging"